# AI 협업 가이드라인

## 1. 프로젝트 개요 (Project Overview)

'소람'은 '주제' 기반의 음성 녹음을 통해 사용자의 내면과 이야기에 집중하여 진정성 있는 연결을 만드는 음성 중심 커뮤니케이션 플랫폼이다. 외모나 스펙이 아닌, 목소리와 생각으로 관계를 시작하는 새로운 소셜 네트워킹을 지향한다.

---

## 2. 핵심 철학 및 목표 (Core Philosophy & Goals)

모든 기획과 개발은 아래의 핵심 철학을 최우선으로 고려해야 한다.

- **진정성 있는 연결:** 무작위적인 만남이 아닌, 공통된 '주제'에 대한 생각을 나누며 관계를 시작한다.
- **내면 중심:** 외모나 스펙 중심의 기존 소셜 앱에서 벗어나, 목소리와 이야기가 중심이 된다.
- **대화의 가치:** 의미 없는 대화가 아닌, 공감과 소통의 가치를 높이는 경험을 제공한다.
- **안전한 익명성:** 최소한의 프로필 정보로 사용자의 프라이버시를 보호하며, 안전한 환경을 제공한다.

---

## 3. 핵심 사용자 경험 (Core User Experience - UX Flow)

'소람'의 사용자 경험은 '진정성 있는 연결'이라는 핵심 철학을 중심으로 설계된다. 특히, **콘텐츠의 가치를 높이고 무분별한 '목소리 쇼핑'을 방지**하기 위해 다음과 같은 정책을 적용한다.

1.  **신규 가입 및 프로필 생성:** 휴대폰 번호 또는 소셜 로그인을 통해 간편 가입 후, 닉네임, 성별, 나이대 등 최소한의 정보를 입력한다.
2.  **첫 주제함 뽑기 및 음성 녹음:** 온보딩 과정에서 샘플 주제함에서 주제를 뽑고, 자신의 첫 음성 답변을 녹음한다.
3.  **홈 화면 및 탐색:**
    - 홈 화면에서 **[랜덤 주제 보기]** 또는 **[주제 찾으러 가기]**를 통해 탐색을 시작한다.
    - 특정 주제를 선택하면, 해당 주제에 대한 다른 사용자들의 답변을 **하루 제한된 횟수(예: 15회) 내에서만** 넘겨볼 수 있다. 이는 콘텐츠의 소모를 방지하고, 사용자가 매일 다시 방문할 이유를 제공한다.
4.  **상호작용 및 프로필 공개 정책:**
    - 탐색 단계에서는 상대방의 **닉네임과 답변 내용만** 볼 수 있다. 프로필 정보(성별, 나이대 등)는 비공개 처리하여 선입견 없이 이야기에 집중하게 한다.
    - 마음에 드는 목소리나 이야기에 재화(CHAT 티켓)를 사용하여 **'대화 요청'**을 보낸다.
    - (`VIEW_RESPONSE` 티켓)을 사용하여 특정 사용자의 다른 답변을 제한된 수량(예: 3개)만큼 추가로 확인할 수 있다.

- **연결 및 소통:**
  - 대화 요청을 보내면 즉시 1:1 채팅방이 열리지만, 요청자만 메시지를 보낼 수 있는 상태가 됩니다. 상대방이 요청을 수락하면 비로소 양방향 소통이 가능한 상태가 됩니다.
  - **연결이 성사된 이 시점에 비로소 서로의 프로필 정보가 공개된다.** 이는 '내면'에 대한 공감이 우선된 후에 관계가 발전하도록 유도하는 핵심 장치다.

---

## 4. 주요 기능 정의 (Key Feature Definitions)

- **주제함:** 시스템이 매일 또는 카테고리별로 제공하는 대화 주제.
- **음성 답변:** 사용자가 주제에 대해 남기는 30초~1분 길이의 음성 녹음.
- **음성 탐색:** 특정 주제에 대해 다른 사용자의 음성 답변을 듣는 기능. **콘텐츠 가치 보존과 재방문 유도를 위해 주제별로 일일 탐색 횟수가 제한된다. 또한, 또한, 더 나은 사용자 경험을 위해 '진짜 활성'(아무도 나가지 않은) PENDING 또는 ACCEPTED 상태로 연결된 사용자의 답변은 탐색 목록에서 제외된다.**
- **호감 표시:** 상대방에게 가벼운 관심을 표현하는 기능.
- **대화 요청:** 재화를 소모하여 상대방과 1:1 채팅방 개설을 요청하는 핵심 기능.
- **채팅 및 통화:** 매칭된 사용자 간의 텍스트 채팅 및 1:1 음성 통화 기능.
- **재화 시스템:** 대화 요청, 추가 답변 확인(`VIEW_RESPONSE`) 등 핵심 기능을 사용하기 위한 인앱 재화(티켓).
- ** 재화 사용 내역:** 사용자가 자신의 재화 획득 및 사용 기록을 시간순으로 확인할 수 있는 기능. 각 내역은 '누구와 연결되었는지' 등 구체적인 맥락과 함께 제공되어 자신의 활동을 쉽게 회고할 수 있도록 돕는다.
- **신고 및 차단:** 안전한 커뮤니티 유지를 위한 필수 기능.

---

채팅방에서

## 5. 데이터베이스 스키마 및 네이밍 규칙

모든 코드와 데이터베이스는 아래 규칙을 따른다.

- **테이블 (Tables):** `PascalCase` (예: `User`, `TopicBox`)
- **컬럼 (Columns):** `camelCase` (예: `createdAt`, `audioUrl`)
- **기본 키 (Primary Key):** `id`
- **외래 키 (Foreign Key):**
  - 일반적인 경우: `{참조 테이블명}Id` (예: `userId`)
  - 역할이 중요한 경우: `{역할}Id` (예: `callerId`, `requesterId`)
- **핵심 테이블 목록:** `User`, `TopicBox`, `VoiceResponse`, `Connection`, `ChatMessage`, `VoiceCall`, `UserTicket`, `Transaction`, `Device`, `Report`, `HiddenContent`, `Sanction`, `UserWithdrawal`, `UnlockedResponse` 등

---

## 6. 기술 스택 (Technology Stack)

- **Backend:** Nest.JS
- **ORM:** Prisma
- **Database:** MySQL (AWS RDS)
- **Infra:** AWS EC2, S3
- **External Services:** SMS (Solapi)
- **Cache/Data Store:** Redis

  Redis는 단순 캐시를 넘어, 서비스의 핵심 비즈니스 로직을 처리하는 중요한 데이터 저장소로 사용됩니다.
  - **OTP 인증:** 사용자의 휴대폰 인증 시 발급되는 일회용 비밀번호(OTP)를 임시로 저장하고 검증합니다.
  - **(미래 확장) Deny List:** 향후 보안 강화를 위해, 탈취되거나 만료시켜야 할 JWT 토큰을 등록하는 Deny List로 활용될 수 있습니다.

---

## 7. AI 협업 규칙 (AI Collaboration Rules)

이 프로젝트에 대한 작업을 진행할 때, AI(너)는 다음 규칙을 반드시 준수해야 한다.

1.  **역할 유지:** 너는 항상 '최고의 프로덕트 매니저, 기획자, 앱 UI 디자이너이자 20년차 풀스택 개발자'의 역할을 수행한다.
2.  **철학 존중:** 모든 제안은 2번 항목의 '핵심 철학'을 최우선으로 고려해야 한다.
3.  **규칙 준수:** 5, 6번 항목의 'DB 규칙'과 '기술 스택'을 반드시 따른다.
4.  **확장성 및 보안 우선:** 모든 설계와 코드는 확장성과 보안, 데이터 무결성을 최우선으로 고려한다.
5.  **논리적 근거 제시:** 질문에 답하거나 새로운 것을 제안할 때는 항상 '왜' 그렇게 해야 하는지에 대한 명확하고 논리적인 근거를 함께 제시한다.
6.  **단순 확인 지양:** 나에게 근거없이 아부하지 않는다. 내가 맞다고 말하는 내용이라도, 스스로 생각하고 판단한 후, 논리적으로 이상한 점이 발견되거나, 더 나은 방법이 있다면 반드시 지적하고 해결책을 제시한다.
7.  **안정성 및 점진적 변경 우선:** (미쳐날뜀 방지 규칙)
    - 기존의 논의된 내용과 작성된 코드를 존중하며, 나의 명시적인 동의 없이 급진적인 구조 변경이나 기능 삭제를 제안하지 않는다.
    - 코드 수정이나 기능 확장을 제안할 때는, 반드시 **변경의 이유와 기대 효과를 명확히 설명**한다.
    - 변경은 가능한 한 **작고 점진적인 단위**로 제안하여 예측 가능성을 높인다.
8.  언제나 **한국어로 답변**할 것!
9.  **사전 확인:** 코드를 수정/생성하기 전에, 기존의 코드를 참고해야 하는 상황이라면, 예측하지 말고 **해당 파일을 정확하게 읽어서파악**한 뒤, 진행한다.
10. 터미널 명령어는 **윈도우** 명령어를 사용한다.
11. **주석 보존**: 코드 변경,삭제,추가 등으로 인해 주석 내용이 올바르지 않은 경우를 제외하고, 최대한 기존의 주석(코드설명)을 유지한다.

---

### 공통 기술 정책 (Common Technical Policies)

서비스 전반의 코드 일관성과 안정적인 클라이언트-서버 통신을 위해 다음과 같은 공통 기술 정책을 정의하고 준수한다.

#### 1. 페이지네이션 (Pagination)

서비스의 모든 목록 조회 API는 성능과 확장성을 고려하여 페이지네이션을 적용한다. 목적에 따라 두 가지 방식의 페이지네이션을 사용한다.

- **커서 기반 페이지네이션 (Cursor-based Pagination)**
  - **목적:** 채팅 메시지, 실시간 피드 등 데이터의 추가/삭제가 빈번하고 '더 보기(무한 스크롤)' 방식의 UX에 적합한 목록에 사용된다.
  - **구현:**
    - **요청 DTO:** `PageQueryDto` (`take`, `cursor`)
    - `take`: 가져올 데이터의 개수 (기본값 10, 최대 50)
    - `cursor`: 마지막으로 조회된 항목의 `id`. 이 `id`를 기준으로 다음 데이터를 조회한다. (첫 페이지는 생략)
  - **응답 DTO:** `PageDto<T>`
    - `data`: 조회된 데이터 배열
    - `meta`: 페이지네이션 메타 정보 (`PageMetaDto`)
      - `totalCount`: 조건에 맞는 전체 데이터 수
      - `endCursor`: 현재 페이지의 마지막 데이터 `id` (다음 요청의 `cursor` 값으로 사용)
      - `hasNextPage`: 다음 페이지 존재 여부 (boolean)

- **오프셋 기반 페이지네이션 (Offset-based Pagination)**
  - **목적:** 관리자 페이지나, 데이터의 변경 빈도가 낮고 특정 페이지로 바로 이동해야 하는 기능에 제한적으로 사용된다.
  - **구현:**
    - **요청 DTO:** `OffsetPageQueryDto` (`page`, `limit`)
    - `page`: 조회할 페이지 번호 (기본값 1)
    - `limit`: 페이지 당 데이터 개수 (기본값 10, 최대 50)
  - **응답 DTO:** `OffsetPageDto<T>`
    - `data`: 조회된 데이터 배열
    - `meta`: 페이지네이션 메타 정보 (`OffsetPageMetaDto`)
      - `page`, `limit`, `total`, `lastPage`, `hasNextPage` 등

#### 2. 전역 예외 처리 필터 (Global Exception Filter)

클라이언트가 일관된 형태로 에러를 처리할 수 있도록, `HttpExceptionFilter`를 전역 필터로 적용하여 모든 HTTP 예외 응답 형식을 표준화한다.

- **파일 위치:** `src/common/filters/http-exception.filter.ts`
- **동작:**
  - NestJS의 `HttpException`을 `catch`하여, 응답 본문을 아래와 같은 통일된 JSON 구조로 가공하여 반환한다.
  - 특히, `class-validator`의 유효성 검사 실패 시 발생하는 복잡한 에러 객체를 클라이언트가 이해하기 쉬운 단순한 메시지로 변환한다.
- **표준 에러 응답 형식:**
  ```json
  {
    "statusCode": 404,
    "message": "해당하는 연결 요청을 찾을 수 없습니다.",
    "error": "Not Found"
  }
  ```

#### 3. 파일 업로드 아키텍처 (Pre-signed URL)

음성 답변 등 사용자가 생성하는 모든 파일은 서버의 부하를 최소화하고 보안을 강화하기 위해 **S3 Pre-signed URL** 방식을 통해 업로드한다.

- **모듈**: `AwsS3Module` (`aws-s3.service.ts`)
- **핵심 동작 흐름**:
  1.  **URL 요청 (Client -> Server)**: 클라이언트는 업로드할 파일의 정보(예: 파일 형식)를 서버의 특정 API(예: `POST /voices/presigned-url`)로 전송하여 파일 업로드 허가를 요청한다.
  2.  **임시 서명 발급 (Server -> S3 -> Server)**: 서버는 `AwsS3Service`를 통해 S3에게 해당 파일에 대한 쓰기 권한이 있는, 짧은 시간(예: 5분) 동안만 유효한 임시 URL(Pre-signed URL)을 발급받는다.
  3.  **URL 응답 (Server -> Client)**: 서버는 발급받은 Pre-signed URL을 클라이언트에게 응답으로 전달한다.
  4.  **직접 업로드 (Client -> S3)**: 클라이언트는 이 URL을 사용하여 파일을 **서버를 거치지 않고 S3 버킷으로 직접 업로드**한다.
  5.  **완료 알림 (Client -> Server)**: 업로드가 완료되면, 클라이언트는 파일의 최종 경로(S3 Key) 등 관련 정보를 서버 API(예: `POST /voices`)로 전송하여 DB에 메타데이터를 저장하고 업로드 프로세스를 완료한다.
- **기대 효과**:
  - **서버 부하 감소**: 대용량 파일 데이터가 서버를 통과하지 않으므로, 서버는 비즈니스 로직 처리에만 집중할 수 있어 성능과 확장성이 향상된다.
  - **보안 강화**: AWS 자격증명을 서버 외부로 노출하지 않고, 필요한 최소한의 권한만 짧은 시간 동안 부여하므로 안전하다.

#### 4. 시간대 처리 정책 (Timezone Handling Policy)

서버의 위치나 설정에 관계없이 일관된 시간 처리를 보장하고, 대한민국 사용자의 경험에 부합하는 서비스를 제공하기 위해 다음과 같은 시간대 처리 원칙을 반드시 준수한다.

- **핵심 원칙: "계산은 KST 기준으로, 저장은 UTC 기준으로"**
  - **저장 (Storage):** 데이터베이스의 모든 날짜/시간 관련 필드(`DATETIME`, `TIMESTAMP` 등)는 반드시 **UTC(협정 세계시)**를 기준으로 저장한다. 이는 Prisma와 `new Date()`의 기본 동작이며, 글로벌 표준으로서 데이터의 일관성을 보장한다.
  - **계산 (Calculation):** 재화 만료일, 이벤트 시작/종료일 등 사용자의 경험과 직접적으로 관련된 모든 시간 계산 로직은 반드시 **대한민국 시간대(KST, `Asia/Seoul`)**를 기준으로 명시적으로 처리해야 한다.

- **구현 방법:**
  - **중앙 관리:** 대한민국 시간대(KST)와 관련된 모든 로직은 `src/common/utils/date-utils.ts` 파일 내의 유틸리티 함수를 통해 처리하는 것을 원칙으로 한다.
  - **사용 금지:** 비즈니스 로직에서 만료일 등을 계산할 때 `new Date()`를 직접 사용하여 시간을 더하는 방식을 사용해서는 안 된다.
  - **올바른 사용 예시:**

    ```typescript
    // src/tickets/tickets.service.ts
    import { calculateKSTExpirationDate } from 'src/common/utils/date-utils';
    // KST 기준으로 7일 뒤 오전 6시에 만료되는 Date 객체(UTC)를 생성
    const expiresAt = calculateKSTExpirationDate(7);
    ```

- **기대 효과:**
  - **버그 예방:** 서버와 클라이언트, 개발 환경과 프로덕션 환경 간의 시간대 차이로 인해 발생할 수 있는 잠재적인 버그를 원천적으로 차단한다.
  - **코드 명확성:** `calculateKSTExpirationDate(7)`과 같이 코드의 의도를 명확하게 표현하여 가독성과 유지보수성을 향상시킨다.
  - **정책 변경 용이성:** 만료 시간 정책이 '오전 6시'에서 '오전 9시'로 변경될 경우, `date-utils.ts` 파일만 수정하면 프로젝트 전체에 일관되게 적용할 수 있다.

---

## 8. 핵심 기능 구현 계획 (Core Feature Implementation Plan)

### 모든 사용자(user) 데이터 조회 시, 반드시 status가 ACTIVE인 사용자만 포함하도록 한다. 데이터베이스 쿼리 레벨에서 WHERE status = 'ACTIVE' 조건을 기본으로 적용하는 것을 원칙으로 한다.

### 채팅 기능 구현 (Chat Feature Implementation)

'소람'의 핵심 가치인 '진정성 있는 연결'을 기술적으로 구현하고, 사용자의 재화 가치를 공정하게 보장하기 위해 채팅 기능은 **"선 소모, 후 환불"** 정책을 기반으로 설계한다. 이는 연결 과정의 불확실성을 제거하고 모든 사용자에게 예측 가능하고 공정한 경험을 제공하는 것을 목표로 한다.

#### 핵심 정책: "선 소모, 후 환불" 및 이원화된 환불 모델

- **문제점:** 기존 '수락 시 차감' 방식은 요청 시점과 수락 시점의 시간 차로 인해, 유효기간이 만료된 재화로 인한 연결 실패 등 불공정한 사용자 경험을 유발할 가능성이 있었다.
- **해결책:** 재화 차감 시점을 **'요청 시점'**으로 변경하여, 요청자의 '연결할 권리'를 요청 시점의 재화 상태로 확정한다. 연결이 성사되지 않았을 경우, 실패 원인에 따라 사용자에게 가장 유리한 방식으로 재화를 **환불**한다.

#### 1단계: 연결 관리 (Connection Management via REST API)

- **모듈**: `ConnectionsModule` (`connections.controller.ts`, `connections.service.ts`)

1.  `POST /connections/request`: **(첫 메시지와 함께 대화 요청하기)**
    - `requesterId`(본인), `addresseeId`(상대방), `voiceResponseId`, 그리고 `initialMessage`(첫 메시지)를 받아 `Connection` 레코드를 생성한다.
    - **(재화 즉시 차감)** 요청과 동시에 요청자의 재화(티켓)를 즉시 차감하고 Transaction에 기록한다. 만약 수신자가 요청을 거절할 경우, 아래 '이원화된 재화 환불 정책'의 정책 A(기회비용 보존 정책)에 따라 재화는 환불된다. 이는 연결 시도의 부담을 줄여 사용자 경험을 개선하기 위함이다.
    - `status`는 `PENDING`으로 설정되며, 이 상태에서 요청자는 메시지를 추가로 보낼 수 있지만, 수신자는 응답할 수 없다.
    - 수신자에게는 "OO님의 메시지가 도착했어요" 와 같은 내용으로 푸시 알림을 전송한다.
    - **(수신자 보호)** 수신자는 채팅방에 입장하여 요청자의 프로필 답변, 요청의 계기가 된 답변(이야기), 그리고 첫 메시지를 확인할 수 있다. 이때 **메시지 읽음 여부는 요청자에게 표시되지 않아** 심리적 압박 없이 충분히 고민하고 응답을 결정할 수 있다.
    - **(대화의 진정성 확보)** 특정 `voiceResponseId`를 기반으로 대화를 요청하려면, 요청자 또한 **해당 답변과 같은 주제에 대한 자신의 답변(이야기)을 먼저 등록**해야만 한다.
    - **(연결의 유일성 보장)** 사용자 간에는 한 번에 하나의 활성화된(`PENDING` 또는 `ACCEPTED`) 연결만 유지된다. 이미 연결이 존재할 경우 새로운 대화 요청을 보낼 수 없다.
    - **(교차 요청 자동 수락)** 만약 상대방이 나에게 보낸 `PENDING` 상태의 요청이 이미 존재할 경우, 새로운 요청을 생성하는 대신 즉시 해당 요청을 수락 처리하여 연결을 성사시킨다.
    - **(중복 요청 방지)** 동일한 상대방에게 처리되지 않은 `PENDING` 상태의 요청을 중복으로 보낼 수 없다.
2.  `POST /connections/:connectionId/accept`: **(대화 요청 수락)**
    - 요청을 받은 사용자(`addresseeId`)가 호출한다.
    - `Connection`의 `status`를 `ACCEPTED`로 변경한다.
    - **이 시점부터 채팅방은 양방향 소통이 가능한 상태가 된다.**
    - 양쪽 사용자에게 연결이 성사되었음을 알리고, 본격적인 대화를 시작하도록 유도한다.
3.  `POST /connections/:connectionId/reject`: **(대화 요청 거절)**
    - 요청을 받은 사용자가 호출한다.
    - `Connection`의 `status`를 `REJECTED`로 변경한다. 재화는 환불되지 않는다.
4.  `GET /connections`: **(내 채팅방 목록 조회)**
    - `status`가 `ACCEPTED`인, 즉 활성화된 채팅방 목록을 조회한다.
    - UX 향상을 위해 상대방 정보, 마지막 메시지, 안 읽은 메시지 수, **차단 여부(`isBlocked`)**, **상대방의 채팅방 나감 여부(`isLeave`)** 등을 함께 반환한다.
5.  `GET /connections/pending`: **(받은 요청 목록 조회)**
    - 나에게 온 대화 요청 중, 아직 수락/거절하지 않은 `PENDING` 상태의 목록을 조회한다.
6.  `GET /connections/sent`: **(보낸 요청 목록 조회)**
    - 내가 보낸 대화 요청 중, 상대방이 아직 처리하지 않은 `PENDING` 상태의 목록을 조회한다.
7.  `DELETE /connections/:connectionId/leave`: **(채팅방 나가기)**
    - 사용자가 '차단'과 같이 부정적인 관계를 형성하지 않고, 자연스럽게 대화를 종료하고 싶을 때 사용한다.
    - **동작**:
      - `Connection`의 `status`는 `ACCEPTED`로 유지한 채, '어떤 사용자가 어떤 채팅방을 나갔는지'에 대한 기록을 별도의 `ConnectionExit` 테이블에 저장한다.
      - 이 작업은 단방향으로, 요청한 사용자의 채팅 목록에만 영향을 준다.
    - **결과 (나간 사용자 A):**
      - `GET /connections` 호출 시, 해당 채팅방이 더 이상 목록에 나타나지 않는다.
    - **결과 (남아있는 사용자 B):**
      - `GET /connections` 호출 시, 채팅방이 목록에 그대로 유지된다.
      - 다만, 응답에 `isLeave: true` 필드가 포함되어, 클라이언트는 이를 보고 입력창을 비활성화하고 "상대방이 나갔습니다"와 같은 안내를 표시할 수 있다.
      - '나가기'는 '차단'이 아니므로, 두 사용자는 추후 다른 음성 답변 등으로 새로운 연결을 맺을 수 있다.
8.  `GET /connections/:id/trigger`: **(채팅방의 연결 계기 조회)**
    - **역할**: 사용자가 채팅방 안에서 '두 사람을 연결해준 최초의 답변'이 무엇이었는지 확인할 수 있게 하여, 대화 시작을 돕는다.
    - **로직**: `Connection`에 저장된 `voiceResponseId`를 기반으로, 해당 주제(`Topic`)와 그 주제에 대한 **나와 상대방의 답변을 모두** 찾아 반환한다.
    - **기대 효과**: 사용자는 "이 사람이 어떤 이야기에 끌렸었지?"와 "나는 뭐라고 답변했었지?"를 동시에 확인하며 자연스럽게 대화를 시작할 수 있다.

#### 이원화된 재화 환불 정책 (Bifurcated Refund Policy)

연결 실패의 원인이 누구에게 있는지에 따라 환불 정책을 이원화하여, 사용자의 자산을 보호하고 어뷰징을 원천 차단한다.

- **정책 A: 상대방의 무응답으로 인한 환불 (기회비용 보존 정책)**
    - **조건:** 수신자의 장기 무응답(예: 3일)으로 판단하여 자동 만료 처리한 경우. (즉, 내 잘못이 아닌 경우)
    - **환불 방식:** **"기회비용 보존"** 원칙에 따라, 상대방이 **언제 무응답했는지와 관계없이**, 환불은 항상 **'대화를 요청했던 시점'을 기준**으로 이루어집니다. 즉, **요청 시점에 남아있던 재화의 유효기간만큼을 그대로 계산**하여 새로운 재화로 지급합니다.
    - **목표:** 사용자가 상대방의 응답을 기다리면서 잃게 된 **기회비용을 완벽하게 보상**하고, 모든 환불 정책을 **'사용한 가치만큼 되돌려준다'**는 명확하고 일관된 원칙하에 운영한다.

#### (미래 구현) 장기 무응답 요청 자동 만료 스케줄러

- 주기적으로(예: 매일 자정) 실행되는 스케줄링 작업을 구현하여, 생성된 지 일정 기간(예: 3일)이 지난 `PENDING` 상태의 요청을 `EXPIRED`로 자동 변경하고, **정책 A(보상)**에 따라 요청자에게 재화를 환불한다. 이는 시스템의 데이터를 깨끗하게 유지하고 사용자의 자산을 보호하는 필수 기능이다.

#### 대화 요청 거절 정책 (Connection Rejection Policy)

사용자에게 더 나은 선택권과 보호 기능을 제공하기 위해, 대화 요청 거절 시 두 가지 옵션을 제공한다.

- **거절하기 (이번만 거절):**
  - **동작:** 사용자가 특정 `답변(이야기)`에 대한 대화 요청만 거절한다.
  - **결과:** 요청자는 해당 `답변(이야기)`으로는 다시 요청을 보낼 수 없지만, 거절한 사용자의 **다른 답변(이야기)**에는 새로 대화를 요청할 수 있다.
  - **구현:** `ConnectionRejection` 테이블에 `(rejectorId, requesterId, voiceResponseId)`를 기록하여 관리한다.

- **차단하기 (거절 + 영구 차단):**
  - **동작:** 사용자가 특정 사용자와의 모든 상호작용을 영구적으로 차단한다.
  - **결과:** 요청자는 앞으로 상대방에게 어떤 종류의 대화 요청도 보낼 수 없으며, 그 반대도 마찬가지다.
  - **구현:** `Block` 테이블에 `(blockerId, blockedId)`를 기록하여 양방향 상호작용을 모두 차단한다.

#### 2단계: 실시간 메시징 (Real-time Messaging via WebSocket)

`status`가 `ACCEPTED`인 `Connection`에 한해서만 동작하는 실시간 채팅 계층.

- **모듈**: `ChatModule` (`chat.gateway.ts`, `chat.service.ts`)
- **주요 로직**:
  1.  **인증 및 연결**: 클라이언트가 WebSocket 연결 시 JWT 토큰으로 사용자를 인증한다.
  2.  **채팅방 입장 (`joinRoom`)**:
      - 클라이언트가 `connectionId`를 보내면, 서버는 먼저 해당 `Connection`의 `status`가 `ACCEPTED`인지, 그리고 요청자가 멤버가 맞는지 **이중으로 검증**한다.
      - 통과 시, 해당 소켓을 `connectionId` 이름의 "방(Room)"에 참여시킨다.
  3.  **메시지 송수신 (`sendMessage`)**:
      - 클라이언트가 `{ connectionId, content }`를 전송한다.
      - 서버는 `ChatMessage` 테이블에 메시지를 저장한 후, 해당 "방(Room)"의 상대방에게 `newMessage` 이벤트를 브로드캐스트한다.
  4.  **메시지 읽음 처리 (Read Receipt)**:
      - 정책: 성능과 확장성을 위해, 개별 메시지가 아닌 '어디까지 읽었는지'를 기준으로 단 한 번의 이벤트로 처리한다.
      - 흐름:
        1. (Client → Server) 사용자가 채팅방에 입장하여 안 읽은 메시지를 확인하면, 화면에 보이는 상대방의 마지막 메시지 ID(lastMessageId)를 담아 chat:read_up_to 이벤트를 전송한다.
        2. (Server) 이벤트를 받아, 해당 채팅방에서 lastMessageId보다 작거나 같은 모든 메시지의 isRead 상태를 true로 **일괄 업데이트(Bulk Update)**한다.
        3. (Server → Client) 처리 완료 후, 해당 채팅방(Room)에 chat:messages_read 이벤트를 전송하여, 메시지를 보냈던 상대방 클라이언트가 '읽음' 상태를 UI에 반영하도록 한다.
  5.  `GET /connections/:connectionId/messages`: (이전 대화 내역 불러오기 - REST API)
  - 채팅방 진입 시, 이전 대화 기록을 조회하기 위한 API
  - 성능을 위해 페이지네이션(무한 스크롤)을 적용한다.
  - `ChatModule`이 아닌 `ConnectionsModule`에 포함하여 역할과 책임을 명확히 분리하는 것을 고려할 수 있다.

### 영구적 콘텐츠 접근 권한 보장 (Permanent Content Access Guarantee)

사용자가 재화를 지불하고 얻은 콘텐츠(예: 다른 사용자의 답변)에 대한 접근 권한이 일회성으로 소멸되는 문제를 해결하고, 지불한 가치만큼 영구적인 권한을 보장하여 사용자 경험을 향상시킨다.

- **문제점:** '답변 보기권'을 사용했을 때, 중복 탐색을 방지하기 위한 임시 저장소(Redis)의 로직 때문에 이미 돈을 내고 본 답변을 다시 볼 수 없는 문제가 있었다.
- **해결책:**
  1.  **`UnlockedResponse` 테이블 신설:** '누가 어떤 답변을 잠금 해제했는지'를 영구적으로 기록하는 전용 테이블을 신설한다. 이는 '회계 장부' 역할의 `Transaction` 테이블과 '임시 캐시' 역할의 `Redis`와 명확히 역할을 분리하여 시스템의 안정성과 확장성을 높인다.
  2.  **로직 수정:** '답변 보기권' 사용 시, 재화 차감 및 트랜잭션 기록과 **동시에** `UnlockedResponse` 테이블에 해당 기록을 원자적 트랜잭션(`prisma.$transaction`)으로 추가한다.
  3.  **API 신설:** `GET /users/me/unlocked-responses` API를 개발하여, 사용자가 자신이 잠금 해제한 모든 답변의 목록을 언제든지 다시 볼 수 있는 '지난 이야기 보기'와 같은 기능을 구현할 수 있는 기반을 마련한다.
- **기대 효과:** 사용자는 자신이 지불한 재화에 대한 합당한 권리를 보장받게 되어 서비스 신뢰도가 향상된다. 또한, 시스템은 역할과 책임이 명확히 분리된 구조를 갖게 되어 더욱 견고하고 유지보수하기 쉬워진다.
- **답변 목록 조회 API 응답 시 정확한 상호작용 상태 제공 (Hybrid Status Logic)**
  1. `GET /users/me/unlocked-responses` API 외에도, 사용자가 잠금 해제한 다른 사용자의 답변 목록을 조회하는 API(예: `GET /users/:authorId/unlocked-responses)에서는 **각 답변(`VoiceResponse`)에 대한 현재 사용자와의 정확한 상호작용 상태(`connectionStatus`또는`interactionStatus`)를 함께 제공\*\*한다. 이는 프론트엔드가 '대화 요청하기', '이미 요청 보냄', '대화중', '거절된 요청' 등의 버튼 상태를 올바르게 표시하도록 하기 위함이다.
  2. **상태 결정 로직 ('하이브리드 로직'):**
     백엔드는 다음 우선순위에 따라 각 답변의 `connectionStatus`를 결정한다.
     - **[1순위] User-to-User 활성 연결 확인:**
       - 현재 사용자와 답변 작성자 사이에 PENDING 또는 ACCEPTED 상태의 Connection이 하나라도 존재하고, 동시에 해당 연결에 ConnectionExit 기록이 없는('아무도 나가지 않은') 경우를 확인한다.
       - **존재할 경우:** 해당 작성자의 **모든 답변**에 대해 해당 활성 연결 상태(`PENDING` 또는 `ACCEPTED`)를 `connectionStatus`로 반환한다. 이는 **'연결의 유일성 보장'(가이드라인 8.1.1)** 정책을 따른다.
     - **[2순위] User-to-Story '나감' 이력 확인:**
       - 1순위에 해당하지 않을 경우, **'현재 조회 중인 특정 voiceResponseId'**에 연결된 Connection이 ACCEPTED 상태이면서, ConnectionExit 테이블에 나간 기록이 있는지 확인한다.
       - 존재할 경우: 오직 해당 답변에 대해서만 'LEFT' (커스텀 상태)를 connectionStatus로 반환한다. 이는 해당 대화가 종료되었음을 의미하며, '이번만 거절'과 동일하게 User-to-Story 레벨로 동작한다.
     - **[3순위] User-to-Story 거절 이력 확인:**
       - 1, 2순위에 모두 해당하지 않을 경우, **'현재 조회 중인 특정 voiceResponseId'**에 대해 현재 사용자가 과거에 보낸 요청이 REJECTED된 Connection 기록이 있는지 확인한다.
       - **존재할 경우:** **오직 해당 답변에 대해서만** `REJECTED` 상태를 `connectionStatus`로 반환한다. 이는 **'이번만 거절'(가이드라인 8.1 - 대화 요청 거절 정책)** 정책을 따른다.
     - **[4순위] User-to-Story '만료' 이력 확인:**
       - 위 1, 2, 3순위에 모두 해당하지 않을 경우, 특정 voiceResponseId에 대해 사용자가 보낸
         요청이 EXPIRED된 기록이 있는지 확인합니다.
       - 존재할 경우: 해당 답변에만 EXPIRED 상태를 반환합니다.
     - **[기본값] 요청 가능:** \* 위 1, 2, 3, 4순위에 모두 해당하지 않으면 `null` (또는 `NONE`)을 `connectionStatus`로 반환한다. 이는 해당 답변에 대해 새로운 대화 요청이 가능함을 의미한다.

- **기대 효과 (추가):**
  이 로직을 통해 백엔드는 '연결의 유일성'과 '이번만 거절'이라는 두 가지 핵심 정책을 모두 만족시키는 상태 정보를 프론트엔드에 명확하게 전달한다. 프론트엔드는 이 값을 기반으로 일관되고 정확한 사용자 인터페이스(버튼 상태 등)를 제공하여 사용자 혼란을 방지하고 서비스 정책을 사용자 경험에 자연스럽게 반영할 수 있다.

### 프로필 답변 기능 구현 (Profile Answer Feature Implementation)

기존의 단편적인 `bio` 필드를 대체하고, 사용자가 '주제'에 대한 구조화된 답변을 통해 자신을 더 깊이 있게 표현하도록 하기 위해 프로필 답변 기능을 구현한다. 이를 통해 서비스의 핵심 가치인 '내면 중심의 진정성 있는 연결'을 강화한다.

#### 핵심 정책 및 흐름

- **회원가입 절차에 통합:** 사용자는 회원가입 시, 닉네임 등 기본 정보와 함께 **프로필 질문에 대한 답변을 필수적으로 제출**해야만 계정을 생성할 수 있다. 이는 모든 활성 사용자가 최소한의 자기표현을 갖추도록 보장하는 핵심 장치다.
- **필수 및 선택 답변:** 사용자는 반드시 1개의 '필수 답변(`isPrimary: true`)'을 포함하여, 최대 4개까지의 프로필 답변을 작성하여 제출한다.
- **`bio` 필드 제거:** 기능적으로 중복되고 품질이 낮은 정보를 유도할 수 있는 `User` 테이블의 `bio` 필드는 스키마와 DTO에서 완전히 제거한다.

#### 데이터베이스 스키마

- **`ProfileQuestion`:** 관리자가 추가/수정/삭제할 수 있는 프로필 질문의 목록을 관리하는 테이블.
- **`ProfileAnswer`:** 사용자가 각 질문에 대해 작성한 답변을 저장하는 테이블.
  - `isPrimary` (Boolean): 필수 답변(1개)과 선택 답변(최대 3개)을 구분하는 플래그.
  - `@@unique([userId, questionId])`: 사용자가 동일한 질문에 중복으로 답변하는 것을 방지하는 DB 제약 조건.

#### API 및 백엔드 로직

1.  **`GET /users/nickname/check` (닉네임 중복 확인 API)**
    - **역할:** 사용자가 회원가입 시 사용하려는 닉네임이 이미 존재하는지 실시간으로 확인한다.
    - **로직:** `nickname`을 쿼리 파라미터로 받아 `User` 테이블을 조회한 후, 사용 가능 여부를 boolean(`isAvailable`)으로 반환한다. 이를 통해 최종 회원가입 요청 전에 중복으로 인한 오류를 방지하여 사용자 경험을 향상시킨다.

2.  **`PUT /users/me/profile-answers` (답변 수정 API)**
    - **역할:** 회원가입 **이후**에, 사용자가 기존에 작성했던 자신의 프로필 답변 전체를 수정할 때 사용된다.
    - **로직:** '전체 교체(Delete and Create)' 전략을 사용한다. 트랜잭션 내에서 사용자의 기존 `ProfileAnswer`를 모두 삭제한 뒤, 요청받은 내용으로 새로운 답변들을 다시 생성하여 데이터 정합성을 보장한다.

3.  **`GET /profile-questions` (질문 목록 조회 API)**
    - **역할:** 클라이언트(앱)가 사용자에게 보여줄 프로필 질문 전체 목록을 조회할 때 사용한다.

4.  **`POST /profile-questions` (질문 생성 API)**
    - **역할:** 관리자가 새로운 프로필 질문을 시스템에 추가할 때 사용한다.

### 주제 기능 구현 (Topic Feature Implementation)

서비스의 핵심인 '주제'를 관리하고 사용자에게 제공하기 위한 API 계층을 구현한다. 사용자가 다양한 주제를 탐색하고, 새로운 대화를 시작할 수 있는 기반을 마련한다.

- **모듈**: `TopicsModule` (`topics.controller.ts`, `topics.service.ts`)
- **핵심 API 엔드포인트**:
  1.  `GET /topics/random`: **(랜덤 주제 조회)**
      - **역할:** 홈 화면의 '랜덤 주제 보기' 기능을 담당한다.
      - **로직:** `TopicBox` 테이블에서 무작위로 주제를 1개 선택하여 반환한다. `exclude` 쿼리 파라미터를 통해 특정 주제 ID를 제외하고 조회할 수 있어, 사용자가 이미 본 주제를 피하는 등의 UX 개선에 활용될 수 있다.
  2.  `GET /topics`: **(주제 목록 조회 및 검색)**
      - **역할:** '주제 찾으러 가기' 기능을 담당한다.
      - **로직:** 페이지네이션을 적용하여 전체 주제 목록을 반환한다. `category` 쿼리 파라미터로 특정 카테고리의 주제만 필터링하거나, `search` 쿼리 파라미터로 주제 제목을 검색하는 기능을 제공한다.
  3.  `GET /topics/:id`: **(특정 주제 조회)**
      - **역할:** 사용자가 특정 주제를 선택했을 때, 해당 주제의 상세 정보를 제공한다.
  4.  `POST /topics`: **(주제 생성 - 관리자용)**
      - **역할:** 시스템에 새로운 주제를 추가하기 위한 API.

### 사용자 인증 및 권한 관리 (Authentication & Authorization)

서비스의 모든 사용자는 역할(일반 사용자, 관리자)에 따라 안전하고 표준화된 인증 절차를 거친다. 인증된 사용자는 JWT(JSON Web Token) 기반의 토큰 시스템을 통해 API 접근 권한을 관리받는다.

#### 1. 핵심 인증 아키텍처 (JWT & Refresh Token)

- **Access Token (액세스 토큰)**
  - **역할**: 실제 API를 호출할 때 사용되는 사용자 신원 증명 토큰.
  - **유효 기간**: 상대적으로 짧은 시간(예: 15분)으로 설정하여 탈취 시 위험을 최소화한다.
  - **검증**: `JwtStrategy`가 토큰의 유효성을 검사하고, 활성 사용자(`status: 'ACTIVE'`)인지 확인한 후 `req.user`에 사용자 정보를 주입한다.

- **Refresh Token (리프레시 토큰)**
  - **역할**: 액세스 토큰이 만료되었을 때, 새로운 액세스 토큰과 리프레시 토큰을 발급받기 위한 토큰.
  - **유효 기간**: 액세스 토큰보다 긴 시간(예: 7일)으로 설정된다.
  - **보안 설계 (서버 사이드 저장)**:
    1.  리프레시 토큰은 발급 즉시 **Redis**에 `rt:<userId>` 형태의 Key로 저장된다.
    2.  토큰 재발급 요청 시, 서버는 클라이언트가 보낸 리프레시 토큰과 Redis에 저장된 토큰이 일치하는지 검증한다.
    3.  **로그아웃** 시 Redis에서 해당 토큰을 삭제하여 즉시 무효화한다.
    4.  **토큰 재발급** 시, 기존 Redis 토큰을 삭제하고 새로 발급한 리프레시 토큰을 저장하여 **토큰 순환(Rotation)**을 구현한다.
  - **기대 효과**: 이 방식은 리프레시 토큰이 탈취되더라도 서버 측에서 제어할 수 있어 매우 높은 수준의 보안을 제공한다.

#### 2. 사용자 인증 흐름 (User Authentication Flow)

1.  `POST /auth/phone/request-otp`: 휴대폰 번호로 4자리 OTP를 요청합니다. 외부 SMS 서비스(Solapi)를 통해 실제 문자를 발송하고, 서버는 이를 3분간 Redis에 저장합니다.
2.  `POST /auth/phone/verify-otp`: OTP를 검증한다.
    - **기존 사용자**: 로그인 성공. Access/Refresh Token 발급.
    - **신규 사용자**: 10분간 유효한 `signupToken` 발급.
3.  `POST /auth/signup`: `signupToken`과 사용자 정보(프로필 답변 포함)를 받아 최종 회원가입을 완료한다.
    - **원자적 처리**: `prisma.$transaction`을 통해 사용자 생성, 프로필 답변 저장, 가입 축하 재화 지급이 모두 성공하거나 모두 실패하도록 보장한다.
    - **2-Column Hashing**: `phoneNumberIndex`(HMAC-SHA256)와 `phoneNumberHash`(Bcrypt)를 생성하여, 빠른 조회와 안전한 저장을 동시에 만족시킨다.

#### 3. 관리자 인증 (Admin Authentication)

- `POST /auth/admin/login`: 관리자는 별도의 이메일/비밀번호 기반 로그인 엔드포인트를 사용한다.
- 성공 시, `role: 'ADMIN'` 정보가 포함된 Access/Refresh Token을 발급받는다.

#### 4. 역할 기반 권한 관리 (Role-Based Access Control - RBAC)

- `@Roles(Role.ADMIN)` 데코레이터와 `RolesGuard`를 사용하여 특정 API가 관리자 권한을 가진 사용자만 호출할 수 있도록 제한한다.

#### 5. 앱 심사 지원 및 개발 편의 기능

- **인증 우회**: `verifyOtp` 로직에는 `.env` 파일에 정의된 테스트용 번호(`TEST_PHONE_NUMBER`, `TEST_SIGNUP_PHONE_NUMBER`)와 OTP(`TEST_OTP`)를 통해 실제 인증 절차를 건너뛸 수 있는 기능이 포함되어 있어, 앱 심사 및 테스트를 용이하게 한다.
- **개발 모드 Guard**: `JwtAuthGuard`는 개발(`development`) 환경에서 `req.user`에 Mock 데이터를 주입하여, 프론트엔드 개발자가 실제 로그인 없이 인증이 필요한 API를 테스트할 수 있도록 지원한다.

#### 6. 디바이스 및 푸시 토큰 관리 (Device & Push Token Management)

푸시 알림을 정확하게 전달하기 위해, 시스템은 사용자의 로그인 상태와 관계없이 디바이스의 푸시 토큰을 관리하고 사용자와 연결하는 과정을 다음과 같이 처리한다.

- **1단계: 익명 디바이스 등록**
  - 사용자가 로그인하지 않은 상태에서 앱을 최초로 실행하면, 클라이언트는 Expo로부터 푸시 토큰(Push Token)을 발급받는다.
  - 클라이언트는 이 토큰을 서버의 `POST /devices` API로 즉시 전송한다.
  - 서버는 `Device` 테이블에 해당 토큰을 저장한다. 이 시점에는 사용자를 특정할 수 없으므로 `userId` 필드는 `null` 상태가 된다.

- **2단계: 로그인 시 사용자 연결**
  - 사용자가 로그인을 시도할 때(정확히는 `POST /auth/phone/verify-otp` 단계), 클라이언트는 인증 정보와 함께 **기존에 발급받았던 푸시 토큰을 반드시 함께** 서버로 전송한다.
  - 서버는 `AuthService`에서 로그인 처리가 성공하면, 함께 전달받은 푸시 토큰을 사용해 `Device` 테이블에서 `userId`가 `null`인 레코드를 찾는다.
  - 해당 레코드를 찾아, `userId` 필드를 `null`에서 현재 로그인한 사용자의 ID로 업데이트하여 디바이스와 사용자를 최종적으로 연결한다.

- **기대 효과**: 이 방식을 통해, 사용자가 로그인하기 전부터 푸시 토큰을 미리 확보하고, 로그인하는 순간 자연스럽게 사용자와 연결할 수 있다. 이는 앱 설치 직후부터 푸시 알림을 받을 수 있는 안정적인 환경을 제공한다.

### 알림 시스템 구현 (Notification System Implementation)

안정적이고 확장 가능한 서비스 운영을 위해, 알림 시스템은 **이벤트 기반 아키텍처(Event-Driven Architecture)**로 구현한다. 이는 특정 로직(예: 대화 수락)과 알림 발송 로직을 분리하여 서비스 간의 의존성을 낮추고, 향후 유지보수를 용이하게 만들기 위함이다.

- **핵심 기술:** Nest.JS `EventEmitterModule`, `expo-server-sdk`

#### 아키텍처 및 동작 원리

1.  **이벤트 발행 (Publisher):**
    - 알림을 발생시키는 주체 (예: `ConnectionsService`, `ChatService`).
    - 자신의 핵심 로직(예: `Connection` 상태를 `ACCEPTED`로 변경)을 완료한 후, `eventEmitter.emit()`을 통해 특정 이벤트(예: `connection.accepted`)와 관련 데이터(Payload)를 발행한다.
    - **중요:** 이벤트를 발행하는 서비스는 알림 기능의 존재 자체를 알지 못하며, 오직 '자신의 상태가 변경되었음'을 알리는 책임만 가진다.

2.  **이벤트 구독 (Listener/Subscriber):**
    - 알림 처리 전용 모듈인 `NotificationsModule` 내의 `NotificationsService`가 이 역할을 수행한다.
    - `@OnEvent('connection.accepted')`와 같은 데코레이터를 사용하여 특정 이벤트를 구독한다.
    - 이벤트가 발행되면, 해당 리스너 함수가 **비동기적으로** 실행된다.

3.  **알림 처리 및 발송 흐름:**
    - 리스너 함수는 이벤트와 함께 전달된 데이터를 받아 다음을 순차적으로 처리한다.
      1.  **알림 DB 저장:** `connection.requested`, `connection.accepted` 와 같이 사용자가 앱 내 '알림함'에서 다시 확인해야 할 필요가 있는 정보는 `Notification` 테이블에 저장한다.
      2.  **푸시 토큰 조회:** 알림을 받을 사용자의 `userId`로 `Device` 테이블에서 하나 이상의 푸시 토큰(`pushToken`)을 조회한다.
      3.  **푸시 알림 발송:** 조회된 푸시 토큰을 이용해 `expo-server-sdk` 라이브러리로 Expo 푸시 서버에 알림 발송을 요청한다.
      4.  **(실시간성 강화)** `chat.message.sent` 이벤트의 경우, '알림함'에 별도로 저장하지 않고 **즉시 푸시 알림만 발송**하여 사용자가 실시간으로 메시지를 인지하도록 한다.
      5.  **(자동 정리) 만료 토큰 처리:** Expo 서버로부터 특정 토큰이 만료되었거나 유효하지 않다(`DeviceNotRegistered`)는 응답을 받으면, 해당 토큰을 `Device` 테이블에서 자동으로 삭제한다. 이를 통해 시스템은 항상 유효한 토큰만 유지하여 불필요한 리소스 낭비를 막고 안정성을 높인다.

#### 기대 효과

- **관심사의 분리 (SoC):** 비즈니스 로직과 알림 로직이 완전히 분리되어 코드의 가독성과 유지보수성이 향상된다.
- **확장성:** '새로운 공지사항', '주간 리포트' 등 새로운 종류의 알림이 필요할 때, 기존 코드를 건드리지 않고 새로운 이벤트와 리스너만 추가하면 된다.
- **안정성:** 외부 푸시 서비스의 장애가 `Connection` 생성과 같은 핵심 비즈니스 로직에 직접적인 영향을 미치지 않는다. 또한, 만료된 토큰을 자동으로 정리하여 시스템을 항상 최적의 상태로 유지한다.

### 콘텐츠 신고, 숨김, 차단 시스템 구현

#### 사용자가 부적절한 콘텐츠나 다른 사용자를 신고할 수 있고 콘텐츠 즉시 숨김 처리 기능 구현

- **모듈**: `ReportsModule` (`reports.controller.ts`, `reports.service.ts`)
- **핵심 로직**:
  1.  **신고 접수**: 사용자는 `POST /reports` API를 통해 특정 사용자(`USER`)나 음성 답변(`VOICE_RESPONSE`)을 신고할 수 있다.
  2.  **신고 데이터 기록**: 신고가 접수되면, `Report` 테이블에 신고자(`reporterId`), 피신고자(`reportedId`), 사유(`reason`) 등의 상세 내역을 기록한다.
  3.  **즉시 숨김 처리**: 사용자가 숨김 처리한 콘텐츠가 더 이상 보이지 않도록 `HiddenContent` 테이블에 관련 정보를 추가하고 조회 조건에 추가하여 조회되지 않도록 처리.
  4.  **차단 관리**: 기존 연결 모듈에서 `거절 + 차단`기능과 동일하게 사용자가 다른 사용자를 차단하면 서로 간의 모든 상호작용을 할 수 없고, 연결(`connection`)상태는 여전히 `ACCEPT`지만, 채팅방 조회에서 `"isBlocked": true` 필드를 반환

### 사용자 차단 기능 구현 (Block Feature Implementation)

사용자가 원치 않는 다른 사용자와의 상호작용을 능동적으로 제어할 수 있도록, 독립적인 차단 기능을 구현한다. 차단은 서비스의 모든 상호작용에 영향을 미치는 강력한 안전장치다.

- **모듈**: `BlocksModule` (`blocks.controller.ts`, `blocks.service.ts`)
- **핵심 정책**:
  - 차단은 단방향으로 기록(`blockerId` -> `blockedId`)되지만, 시스템은 이를 **양방향으로 해석**하여 모든 상호작용(대화 요청, 콘텐츠 노출 등)을 차단한다. 즉, A가 B를 차단하면 B도 A에게 상호작용할 수 없다.
  - 사용자는 언제든지 자신이 차단한 사용자 목록을 확인하고, 개별적으로 차단을 해제할 수 있다.
- **핵심 API 엔드포인트**:
  1.  `POST /blocks`: **(사용자 차단)**
      - `blockedId`를 받아 특정 사용자를 차단하고 `Block` 테이블에 기록한다.
      - 스스로를 차단하거나, 이미 차단한 사용자를 중복으로 차단할 수 없다.
      - 차단을 실행하기 전, 시스템은 차단 대상이 나에게 보낸 PENDING 상태의 대화 요청이 있는지 확인한다.
      - 만약 해당 요청이 존재한다면, 차단 작업의 일부로 해당 요청을 자동으로 REJECTED 상태로 변경하고, 요청자에게 재화를 환불한다. ('대화 요청 거절 정책'의 환불 로직과 동일하게 동작)
      - 이 '선 거절(환불), 후 차단' 로직은 prisma.$transaction 내에서 원자적으로 처리되어 데이터 정합성을 보장합니다.
  2.  `DELETE /blocks/:userId`: **(사용자 차단 해제)**
      - 차단했던 사용자의 `userId`를 파라미터로 받아 `Block` 레코드를 삭제하여 차단을 해제한다.
  3.  `GET /blocks`: **(차단 목록 조회)**
      - 현재 로그인한 사용자가 차단한 모든 사용자의 목록과 차단 시점을 함께 반환한다.

### 앱 심사 지원 기능 (App Review Support)

#### 텍스트 우선 MVP 전략 (Text-First MVP Strategy)

빠른 서비스 출시와 앱 심사 통과 확률을 극대화하기 위해, 초기 MVP(Minimum Viable Product) 버전은 **텍스트 기반의 답변 기능**을 우선적으로 제공하는 전략을 채택한다.

- **목표:** 서비스의 핵심 가치인 '주제 기반의 연결'을 검증하되, 구현 복잡성이 높은 음성 관련 기능(녹음, 저장, 검증, 재생)을 제외하여 개발 속도를 높이고 앱 심사 리스크를 최소화한다.
- **전략:**
  1.  **기능 축소:** 초기 버전에서는 음성 답변 대신 텍스트로 답변을 작성하도록 한다.
  2.  **위험 최소화:** 상대적으로 정책이 까다로운 사용자 생성 음성 콘텐츠를 심사 버전에서 제외하여, 기술 및 정책적 거절 가능성을 낮춘다.
  3.  **유연한 확장:** 데이터베이스(`VoiceResponse` 모델)는 `type`과 `textContent` 필드를 추가하는 방식으로 설계하여, 향후 음성 기능을 추가할 때 기존 데이터 구조와 API를 재사용 및 확장할 수 있도록 구현한다. (하위 호환성 및 확장성 확보)
- **기대 효과:** 핵심 기능만으로 빠르게 시장에 진입하여 사용자 반응을 확인하고, 안정적으로 서비스를 운영한 뒤 점진적으로 핵심 기능인 음성 관련 기능을 고도화한다.

### 사용자 탈퇴 및 재가입 방지 정책

사용자의 개인정보를 보호하면서도, 첫 가입 시 제공되는 재화를 노린 무분별한 가입-탈퇴 반복(어뷰징)을 방지하기 위해 다음과 같은 '소프트 탈퇴' 및 재가입 방지 정책을 구현한다.

- **핵심 목표:** 사용자의 '잊힐 권리'를 존중하여 `User` 테이블의 개인 식별 정보를 완전히 제거하는 동시에, 별도의 `UserWithdrawal` 테이블에 재가입 방지를 위한 최소한의 정보('어떤 번호'가 '언제' 탈퇴했는지)를 일정 기간 보관한다.

#### 1단계: 사용자 탈퇴 처리 (`DELETE /users/me`)

1.  **사용자 상태 변경:** `User` 테이블에서 해당 사용자의 `status`를 `ACTIVE`에서 `WITHDRAWN`으로 변경한다.
2.  **개인정보 익명화:**
    - `nickname`을 '탈퇴한 사용자'와 같이 식별 불가능한 이름으로 변경한다.
    - 재가입이 가능하도록 `phoneNumberIndex`, `phoneNumberHash` 등 개인 식별 정보를 `null`로 설정하여 `User` 테이블에서 완전히 제거한다.
3.  **탈퇴 기록 생성:**
    - `UserWithdrawal` 테이블에 새로운 레코드를 생성한다.
    - 이 레코드에는 탈퇴한 사용자의 `userId`와 함께, 재가입 방지 정책의 근거가 될 **`phoneNumberIndex` 값**을 저장한다.
4.  **푸시 토큰 삭제:** `Device` 테이블에서 해당 사용자와 연결된 모든 푸시 알림 토큰을 삭제하여, 더 이상 알림이 전송되지 않도록 한다.
5.  **원자적 처리:** 위의 모든 데이터베이스 변경 작업은 `prisma.$transaction`으로 묶어, 하나라도 실패할 경우 모든 변경사항이 롤백되도록 보장한다.

#### 2단계: 신규 회원가입 시 재가입 방지

1.  **탈퇴 이력 조회:** 사용자가 휴대폰 번호로 회원가입을 시도하면, 해당 번호로 생성한 `phoneNumberIndex`를 이용해 `UserWithdrawal` 테이블에서 가장 최근의 탈퇴 기록을 조회한다.
2.  **정책 기간 검사:**
    - 만약 탈퇴 기록이 존재하고, 탈퇴일로부터 정책으로 정한 기간(예: 30일)이 지나지 않았다면, "탈퇴 후 30일 동안 재가입할 수 없습니다."와 같은 메시지를 반환하며 가입을 차단한다.
    - 탈퇴 기록이 없거나 정책 기간이 지났다면, 정상적으로 회원가입 절차를 진행한다.

#### 기대 효과

- **개인정보 보호와 어뷰징 방지의 양립:** 활성 사용자 테이블에서는 개인정보를 파기하면서도, 분리된 공간에서 어뷰징 방지 정책을 효과적으로 수행할 수 있다.
- **데이터 무결성:** 사용자와 연결된 다른 데이터(채팅, 연결 등)를 삭제하지 않고 보존하여 서비스 데이터의 일관성을 유지한다.
- **유연한 정책 관리:** 향후 재가입 방지 기간을 변경하거나 정책을 수정해야 할 때, 회원가입 로직의 기간 검사 부분만 수정하면 되므로 유연하게 대응할 수 있다.

### 재화 및 보상 시스템 정책

사용자의 꾸준한 재방문을 유도하고 공정한 보상 시스템을 제공하여 서비스의 핵심 가치를 보존하고, 지속 가능한 인앱 경제를 구축하기 위해 다음과 같은 재화 정책을 구현한다.

- **핵심 목표:** 재화의 속성을 **'일일 소멸성', '기간제 누적성', '영구성'**으로 명확히 분리하여 관리한다. 이를 통해 사용자에게는 직관적인 경험을 제공하는 동시에, 재화 가치의 하락(인플레이션)과 결제 유저에 대한 역차별 문제를 방지한다.

#### 1단계: 재화 종류별 속성 정의

시스템은 재화의 출처에 따라 다음과 같이 세 가지 유형으로 정책을 구분하여 관리한다.

1.  **일일 재화:** 매일 정해진 시간에 지급되며, 사용하지 않은 재화는 다음 날 **소멸**된다. 사용자의 매일 재방문 유도를 목표로 한다.
2.  **이벤트/가입 재화:** 신규 가입, 이벤트 보상 등으로 지급되며, 정해진 기간(예: 7일) 동안만 유효한 **기간제** 재화다.
3.  **결제 재화:** 사용자가 유료로 구매한 재화로, 유효기간 없이 영구적으로 소유하는 **영구성** 자산이다.

#### 2단계: 사용자 경험(UX) 및 시스템 규칙 적용

사용자에게는 직관성을, 시스템 내부적으로는 명확한 규칙을 적용한다.

1.  **재화 표시 규칙:**
    - **통합 표시:** 메인 화면 등에서는 모든 재화를 합산한 **총량**을 표시하여 직관성을 높인다.
    - **분리 표시:** '재화 상세 보기' 페이지에서는 재화의 출처별 수량과 유효기간을 명확히 안내하여 **투명성**을 제공한다.
2.  **재화 소진 규칙:** 사용자가 재화를 사용할 때, 시스템은 유효기간이 가장 짧은 **`일일 재화`부터 우선적으로 차감**하여 사용자의 이익을 극대화한다.

#### 기대 효과

- **공정성 및 사용자 만족도 증대:** 결제 유저가 불이익을 받지 않으며, 모든 사용자가 매일 공평한 혜택을 누릴 수 있어 시스템에 대한 신뢰도가 향상된다.
- **사용자 재방문율 향상:** 매일 소멸되는 '일일 재화'는 사용자에게 꾸준한 접속 동기를 부여하여 서비스 활성화에 기여한다.
- **지속 가능한 인앱 경제:** 재화의 무한 누적을 방지하여 인플레이션을 억제하고, 결제 재화의 가치를 보존하여 안정적인 수익 모델을 뒷받침한다.

### 스케줄링 및 백그라운드 작업 (Scheduling & Background Tasks)

서비스의 자동화된 운영 및 정책 적용을 위해, 특정 시간에 주기적으로 실행되는 백그라운드 작업을 구현한다. 이는 주로 사용자의 개입 없이 시스템이 스스로 처리해야 하는 로직에 사용된다.

- **핵심 기술:** Nest.JS `ScheduleModule` (`@nestjs/schedule`)
- **모듈**: `TasksModule` (`tasks.service.ts`)

#### 주요 스케줄링 작업

1.  **일일 재화 지급 및 소멸 (`handleCron`)**
    - **역할:** 가이드의 '일일 재화' 정책을 자동으로 실행한다.
    - **실행 주기:** 매일 정해진 시간(예: 오전 6시)에 실행된다.
    - **핵심 로직 (단일 트랜잭션 내에서 처리):**
      1.  **소멸:** 모든 활성 사용자의 `UserTicket` 중 `sourceType`이 `DAILY`인 재화를 일괄 삭제한다.
      2.  **지급:** 모든 활성 사용자(`status: 'ACTIVE'`)에게 정책에 정의된 새로운 '일일 재화'를 일괄적으로 지급하고, 관련 `Transaction` 기록을 생성한다.

### 재화 사용 내역 조회 기능 구현 (Transaction History Feature Implementation)

사용자가 자신의 재화 활동을 명확하고 의미 있게 파악할 수 있도록, 서버 중심의 데이터 가공을 통해 직관적인 사용 내역 API를 제공한다.

- **모듈**: `TransactionsModule` (`transactions.controller.ts`, `transactions.service.ts`)
- **핵심 API 엔드포인트**:
  1.  `GET /transactions`: **(내 재화 사용 내역 조회)**
      - **역할**: 인증된 사용자가 자신의 모든 재화 획득/사용 내역을 조회한다.
      - **요청**: 커서 기반 페이지네이션(`take`, `cursor`)과 필터링(`type: 'ALL' | 'EARN' | 'USE'`)을 지원한다.
      - **응답**: `PageDto<TransactionHistoryDto>` 형태로, 클라이언트가 UI를 그리는 데 필요한 모든 정보가 가공된 상태로 전달된다.

- **핵심 서버 로직 (데이터 가공 및 변환)**:
  - 클라이언트의 부담을 최소화하기 위해, **서버에서 모든 데이터 조합 및 텍스트 생성을 책임진다.**
  - `TransactionsService`는 DB의 원본 `Transaction` 데이터를 조회한 후, 각 레코드의 `reason`과 `referenceId`를 분석한다.
  - 예를 들어 `reason`이 `CONNECTION_ACCEPTED`인 경우, `referenceId`를 이용해 관련 `Connection` 및 상대방 `User` 정보를 조회하여 **`'OOO님과 대화 시작'`** 과 같은 동적 `displayText`를 생성한다.
  - 또한, `reason`에 따라 클라이언트가 아이콘을 쉽게 렌더링할 수 있도록 **`iconType`** (예: `CHAT_START`, `WELCOME_GIFT`)을 함께 제공한다.
  - 이 과정에서 발생할 수 있는 **N+1 쿼리 문제를 회피**하기 위해, 필요한 모든 연관 데이터(예: 여러 `Connection` 정보)를 일괄적으로 조회하여 메모리에서 조합하는 최적화 로직을 적용한다.
- **기대 효과**: 클라이언트는 서버가 제공하는 `displayText`와 `iconType`을 그대로 화면에 표시하기만 하면 되므로, 프론트엔드 로직이 단순화되고 클라이언트와 서버의 역할이 명확하게 분리된다.
